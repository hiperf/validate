function e(e,r={},o="en",i,l){let n=null;for(let e in i)if(e==o){n=i[e];break}if(null===n)for(let e in l)if(e==o){n=l[e];break}if(null===n)throw new Error(`Lang "${o}" doesn't exist in locales object. Available locales - ${Object.keys(l).join(", ")}, {Object.keys(userLocales).join(', ')}`);let a=n[e];if(void 0===a)throw new Error(`Key "${e}" does not exist in "${o}" dictionary`);for(let e in r)a=a.replace(`%${e}`,r[e]);return a}function r({validatorConfigValue:r,validatorConfig:o,validatorName:i,fieldName:l,dataValue:n,lang:a,userLocales:t,libLocales:s}){let f="";if(function(e){return"object"==typeof e&&!Array.isArray(e)&&null!==e}(o)){if(!("value"in o))throw new Error('Missing "value" key in validator config');"error"in o&&(f=o.error)}return f||`${l}: `+e(`error-${i}`,{e:r,v:n},a,t,s)}function o(o){if(!("locales"in o))throw new Error("options.locales is required to be defined");if(!("validators"in o))throw new Error("options.validators is required to be defined");const i=o.locales,l=o.validators,n=["required"];function a(e,r={},o={}){return e in r?r[e]:e in o?o[e]:null}return function(o,t,s="en",f={}){let u=[];"locales"in f||(f.locales={}),"validators"in f||(f.validators={});for(let c in o){const d=o[c],v=!("required"in d)||d.required;let w;if(t.hasOwnProperty(c)){w=t[c];for(let o in d){if(n.includes(o))continue;const t=a(o,f.validators,l);if(!t&&"custom"!=o)throw new Error(e("error-unknown-validator",{v:o},s,f.locales,i));const v=d[o];let b=v;if(a("isObject",f.validators,l)(v)){if(!("value"in v))throw new Error(e("error-validator-config-is-missing-value",{v:o},s,f.locales,i));b=v.value}if("custom"===o){const e=Array.isArray(v)?v:[v];for(let r of e){const e=r(w);for(let r of e.errors)u.push(r)}}else{if(!t(w,b,v)){const e=r({validatorConfigValue:b,validatorConfig:v,validatorName:o,fieldName:c,dataValue:w,lang:s,userLocales:f.locales,libLocales:i});u.push(e)}}}}else v&&u.push(e("field-required",{fieldName:c},s,f.locales,i))}return{isValid:0===u.length,errors:u}}}export{o as default};
